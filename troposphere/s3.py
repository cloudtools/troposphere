# Copyright (c) 2012-2019, Mark Peek <mark@peek.org>
# All rights reserved.
#
# See LICENSE file for full license.
#
# *** Do not modify - this file is autogenerated ***
# Resource specification version: 2.20.0

from . import AWSObject
from . import AWSProperty
from troposphere import Tags
from .validators import boolean
from .validators import integer
from .s3_validators import BucketMixin
from .s3_validators import RuleMixin
from .validators import positive_integer
from .s3_validators import s3_transfer_acceleration_status


try:
    from awacs.aws import Policy

    policytypes = (dict, Policy)
except ImportError:
    policytypes = dict,

Private = "Private"
PublicRead = "PublicRead"
PublicReadWrite = "PublicReadWrite"
AuthenticatedRead = "AuthenticatedRead"
BucketOwnerRead = "BucketOwnerRead"
BucketOwnerFullControl = "BucketOwnerFullControl"
LogDeliveryWrite = "LogDeliveryWrite"


class AccelerateConfiguration(AWSProperty):
    props = {
        'AccelerationStatus': (s3_transfer_acceleration_status, True),
    }


class Destination(AWSProperty):
    props = {
        'BucketAccountId': (basestring, False),
        'BucketArn': (basestring, True),
        'Format': (basestring, True),
        'Prefix': (basestring, False),
    }


class DataExport(AWSProperty):
    props = {
        'Destination': (Destination, True),
        'OutputSchemaVersion': (basestring, True),
    }


class StorageClassAnalysis(AWSProperty):
    props = {
        'DataExport': (DataExport, False),
    }


class TagFilter(AWSProperty):
    props = {
        'Key': (basestring, True),
        'Value': (basestring, True),
    }


class AnalyticsConfiguration(AWSProperty):
    props = {
        'Id': (basestring, True),
        'Prefix': (basestring, False),
        'StorageClassAnalysis': (StorageClassAnalysis, True),
        'TagFilters': ([TagFilter], False),
    }


class ServerSideEncryptionByDefault(AWSProperty):
    props = {
        'KMSMasterKeyID': (basestring, False),
        'SSEAlgorithm': (basestring, True),
    }


class ServerSideEncryptionRule(AWSProperty):
    props = {
        'ServerSideEncryptionByDefault':
            (ServerSideEncryptionByDefault, False),
    }


class BucketEncryption(AWSProperty):
    props = {
        'ServerSideEncryptionConfiguration':
            ([ServerSideEncryptionRule], True),
    }


class CorsRule(AWSProperty):
    props = {
        'AllowedHeaders': ([basestring], False),
        'AllowedMethods': ([basestring], True),
        'AllowedOrigins': ([basestring], True),
        'ExposedHeaders': ([basestring], False),
        'Id': (basestring, False),
        'MaxAge': (integer, False),
    }


class CorsConfiguration(AWSProperty):
    props = {
        'CorsRules': ([CorsRule], True),
    }


class InventoryConfiguration(AWSProperty):
    props = {
        'Destination': (Destination, True),
        'Enabled': (boolean, True),
        'Id': (basestring, True),
        'IncludedObjectVersions': (basestring, True),
        'OptionalFields': ([basestring], False),
        'Prefix': (basestring, False),
        'ScheduleFrequency': (basestring, True),
    }


class AbortIncompleteMultipartUpload(AWSProperty):
    props = {
        'DaysAfterInitiation': (positive_integer, True),
    }


class NoncurrentVersionTransition(AWSProperty):
    props = {
        'StorageClass': (basestring, True),
        'TransitionInDays': (positive_integer, True),
    }


class Transition(AWSProperty):
    props = {
        'StorageClass': (basestring, True),
        'TransitionDate': (basestring, False),
        'TransitionInDays': (integer, False),
    }


class Rule(RuleMixin, AWSProperty):
    props = {
        'AbortIncompleteMultipartUpload':
            (AbortIncompleteMultipartUpload, False),
        'ExpirationDate': (basestring, False),
        'ExpirationInDays': (positive_integer, False),
        'Id': (basestring, False),
        'NoncurrentVersionExpirationInDays': (positive_integer, False),
        'NoncurrentVersionTransition': (NoncurrentVersionTransition, False),
        'NoncurrentVersionTransitions':
            ([NoncurrentVersionTransition], False),
        'Prefix': (basestring, False),
        'Status': (basestring, True),
        'TagFilters': ([TagFilter], False),
        'Transition': (Transition, False),
        'Transitions': ([Transition], False),
    }


class LifecycleConfiguration(AWSProperty):
    props = {
        'Rules': ([Rule], True),
    }


class LoggingConfiguration(AWSProperty):
    props = {
        'DestinationBucketName': (basestring, False),
        'LogFilePrefix': (basestring, False),
    }


class MetricsConfiguration(AWSProperty):
    props = {
        'Id': (basestring, True),
        'Prefix': (basestring, False),
        'TagFilters': ([TagFilter], False),
    }


class FilterRule(AWSProperty):
    props = {
        'Name': (basestring, True),
        'Value': (basestring, True),
    }


class S3KeyFilter(AWSProperty):
    props = {
        'Rules': ([FilterRule], True),
    }


class NotificationFilter(AWSProperty):
    props = {
        'S3Key': (S3KeyFilter, True),
    }


class LambdaConfiguration(AWSProperty):
    props = {
        'Event': (basestring, True),
        'Filter': (NotificationFilter, False),
        'Function': (basestring, True),
    }


class QueueConfiguration(AWSProperty):
    props = {
        'Event': (basestring, True),
        'Filter': (NotificationFilter, False),
        'Queue': (basestring, True),
    }


class TopicConfiguration(AWSProperty):
    props = {
        'Event': (basestring, True),
        'Filter': (NotificationFilter, False),
        'Topic': (basestring, True),
    }


class NotificationConfiguration(AWSProperty):
    props = {
        'LambdaConfigurations': ([LambdaConfiguration], False),
        'QueueConfigurations': ([QueueConfiguration], False),
        'TopicConfigurations': ([TopicConfiguration], False),
    }


class PublicAccessBlockConfiguration(AWSProperty):
    props = {
        'BlockPublicAcls': (boolean, False),
        'BlockPublicPolicy': (boolean, False),
        'IgnorePublicAcls': (boolean, False),
        'RestrictPublicBuckets': (boolean, False),
    }


class AccessControlTranslation(AWSProperty):
    props = {
        'Owner': (basestring, True),
    }


class EncryptionConfiguration(AWSProperty):
    props = {
        'ReplicaKmsKeyID': (basestring, True),
    }


class ReplicationDestination(AWSProperty):
    props = {
        'AccessControlTranslation': (AccessControlTranslation, False),
        'Account': (basestring, False),
        'Bucket': (basestring, True),
        'EncryptionConfiguration': (EncryptionConfiguration, False),
        'StorageClass': (basestring, False),
    }


class SseKmsEncryptedObjects(AWSProperty):
    props = {
        'Status': (basestring, True),
    }


class SourceSelectionCriteria(AWSProperty):
    props = {
        'SseKmsEncryptedObjects': (SseKmsEncryptedObjects, True),
    }


class ReplicationRule(AWSProperty):
    props = {
        'Destination': (ReplicationDestination, True),
        'Id': (basestring, False),
        'Prefix': (basestring, True),
        'SourceSelectionCriteria': (SourceSelectionCriteria, False),
        'Status': (basestring, True),
    }


class ReplicationConfiguration(AWSProperty):
    props = {
        'Role': (basestring, True),
        'Rules': ([ReplicationRule], True),
    }


class VersioningConfiguration(AWSProperty):
    props = {
        'Status': (basestring, True),
    }


class RedirectAllRequestsTo(AWSProperty):
    props = {
        'HostName': (basestring, True),
        'Protocol': (basestring, False),
    }


class RedirectRule(AWSProperty):
    props = {
        'HostName': (basestring, False),
        'HttpRedirectCode': (basestring, False),
        'Protocol': (basestring, False),
        'ReplaceKeyPrefixWith': (basestring, False),
        'ReplaceKeyWith': (basestring, False),
    }


class RoutingRuleCondition(AWSProperty):
    props = {
        'HttpErrorCodeReturnedEquals': (basestring, False),
        'KeyPrefixEquals': (basestring, False),
    }


class RoutingRule(AWSProperty):
    props = {
        'RedirectRule': (RedirectRule, True),
        'RoutingRuleCondition': (RoutingRuleCondition, False),
    }


class WebsiteConfiguration(AWSProperty):
    props = {
        'ErrorDocument': (basestring, False),
        'IndexDocument': (basestring, False),
        'RedirectAllRequestsTo': (RedirectAllRequestsTo, False),
        'RoutingRules': ([RoutingRule], False),
    }


class Bucket(BucketMixin, AWSObject):
    resource_type = "AWS::S3::Bucket"

    props = {
        'AccelerateConfiguration': (AccelerateConfiguration, False),
        'AccessControl': (basestring, False),
        'AnalyticsConfigurations': ([AnalyticsConfiguration], False),
        'BucketEncryption': (BucketEncryption, False),
        'BucketName': (basestring, False),
        'CorsConfiguration': (CorsConfiguration, False),
        'InventoryConfigurations': ([InventoryConfiguration], False),
        'LifecycleConfiguration': (LifecycleConfiguration, False),
        'LoggingConfiguration': (LoggingConfiguration, False),
        'MetricsConfigurations': ([MetricsConfiguration], False),
        'NotificationConfiguration': (NotificationConfiguration, False),
        'PublicAccessBlockConfiguration':
            (PublicAccessBlockConfiguration, False),
        'ReplicationConfiguration': (ReplicationConfiguration, False),
        'Tags': (Tags, False),
        'VersioningConfiguration': (VersioningConfiguration, False),
        'WebsiteConfiguration': (WebsiteConfiguration, False),
    }


class BucketPolicy(AWSObject):
    resource_type = "AWS::S3::BucketPolicy"

    props = {
        'Bucket': (basestring, True),
        'PolicyDocument': (dict, True),
    }
